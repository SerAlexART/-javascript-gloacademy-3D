'use strict';

// * Делегирование событий - один из базовых паттернов работы с DOM контентом
// Паттерн это некое шаблонное действие для решения часто встречающихся проблем при проектировании программы. Паттерн делегирование событий направлен на то, чтобы уменьшить количество обработчиков событий на одной странице, что значительно повышает производительность программы.
console.log('Делегирование событий - один из базовых паттернов работы с DOM контентом');

// 1) Start Code
console.log(`____________________________________________________________________________________

`);

// * Проблема в том, что одинаковых обработчиков событий на кнопку столько же, сколько и кнопок. И проблема будет увеличиваться с появлением всё болших кнопок. Представим, что у нас 50, 100 или 1.000 кнопок! Достаточно открыть любую социальную сеть и посмотреть сколько кнопок всего на ОДНОМ комментарии, а их тысячи...


// * 2) Изменение обработчика события с помощью делегирования
console.log(' 2) Изменение обработчика события с помощью делегирования');



const textBlock = document.querySelector('.text-block');
const addBtn = document.getElementById('add-btn');
const btnsBlock = document.querySelector('.buttons-block');
const main = document.querySelector('main');

let buttons = document.querySelectorAll('.btn');


// Функция изменения текста для textBlock
const changeText = (text) => {
    textBlock.textContent = text;
};

// Функция добавления новой кнопки
const getNewButton = () => {
    // Клонируем первую кнопку, при этом не передаём true
    const newBtn = buttons[0].cloneNode();

    // Привязываем текст новой кнопки от длины NodeList`а buttons и добавляем 0 через тернарный оператор
    newBtn.textContent = buttons.length + 1 >= 10 ?
        buttons.length + 1 : `0${buttons.length + 1}`;

    // Добавляем новую кнопку в btnsBlock
    btnsBlock.append(newBtn);

    // * Переорпделеяем переменную, чтобы она обновлялась, без этого кнопка вседа будет с тексом 06, так как не обновляется длина buttons
    buttons = document.querySelectorAll('.btn');
};

// * 1) Вешаем обработчик события на родительский блок btnsBlock с кнопками
// Функция внутри обработчика получает event, то-есть то событие, которое происходит на нашем элементе. Если мы вспомним всплытие и перехват, то точно всппомним, что клик происшедший на дочернем элементе происходит и на дочернем элементе и на блоке родителе и на блоке родителя родителя и т.д. вплоть то тега body и html.
// Таким образом мы можем повесить обработчик события на нужный блок родителя и проверять на какой элемент мы кликнули. И если этот элемент кнопка, то активировать нужную нам функцию changeText()

// * 4-1) Вешаем обработчик события на main
main.addEventListener('click', (event) => {
    // btnsBlock.addEventListener('click', (event) => {
    // Выводи в консоль цель самого события, то-есть кнопки
    console.log(event.target);

    // Выводи event.target в виде объекта и найдём свойство tagName
    console.dir(event.target);

    // * 2-0) Делаем проверку на имя тега 'BUTTON' и запускаем функцию changeText()
    // * И теперь абсолютно неважно сколько будет кнопок, хоть 1.000.000, обработчик события всего один
    // if (event.target.tagName === 'BUTTON') {
    //     changeText(event.target.textContent);
    // }

    // * 2-1) Можно немного улучить
    // Если мы кликнули НЕ ! по 'BUTTON', то возврашать return пустоту. Чтобы мы не кликнули и если это не будет 'BUTTON', то функция завершит свою работу
    // if (event.target.tagName !== 'BUTTON') {
    //     return;
    // }

    // * 3-1) contains() - мы можем сделать проверку на класс через contains()
    // . не указываем, так как принимает только класс
    // Если мы кликнули НЕ ! по 'BUTTON', то возврашать return пустоту. Чтобы мы не кликнули и если это не будет 'BUTTON', то функция завершит свою работу
    // if (!event.target.classList.contains('btn')) {
    //     return;
    // }

    // * 3-2) matches() - мы можем сделать проверку на класс через matches()
    // Принимает в себя все селекторы и нужно указывать . # и т.д. и принимает сложные селекторы вроде button.btn
    // Если мы кликнули НЕ ! по 'BUTTON', то возврашать return пустоту. Чтобы мы не кликнули и если это не будет 'BUTTON', то функция завершит свою работу
    // if (!event.target.matches('button.btn')) {
    //     return;
    // }

    // * 4-2) Переписываем обработчик события else if
    // Выполняем функцию changeText() только если кликнули по button с классом btn
    // Выполняем фунцию getNewButton() только если id элемента, по которому мы кликнули === 'add-btn
    // if (event.target.matches('button.btn')) {
    //     changeText(event.target.textContent);
    // } else if (event.target.id === 'add-btn') {
    //     getNewButton();
    // }

    // * 4-3) closest() - Проверяет являвется ли наш event.taget дочерним элементом какого-то другого элемента. Принимает строку ''
    // Делает проверку от ребёнка на который кликнули и поднимает на уровень выше до указанного нами элемента. Возвращает true или false
    // Добавляем проверку для button, что является дочерним элементом .buttons-block
    if (event.target.matches('button') && event.target.closest('.buttons-block')) {
        changeText(event.target.textContent);
    } else if (event.target.id === 'add-btn') {
        getNewButton();
    }

    // * 2-2) И благодаря проверки до функции changeText не дойдёт дело из-за return из пункта 2-1
    // changeText(event.target.textContent);
});



// * Полезные методы:
// classList.contains() - проверка на класс
// matches() - проверка на любые селекторы
// closest() - проверка на родителя цели event.target
// event.target.id


// * Где стоит применять Дилегирование?
// Применяется на одинаковых элементах вроде карточек товара, комменратирев и т.д.
// В нашем примере это кнопку 01, 02, 03 и т.д.
// Удобно использовать на блоке внутри которого одинаковые элементы в большои количестве, которые делают один функционал


// * Где НЕ стоит применять Дилегирование?
// В текущем примене не стоило вешать обработчик события на main, чтобы искать кнопку "Добавить кнопку". Стоило повесито отдельный обработчик на данную кнопку.
// Если вешать на main ради одной кнопки, то это усложняет читаемость кода и мы сами запутаемся в количестве проверок и пойдут ошибки