// 'use strict';

// * Асинхронный код JS, Промисы/Promise, Fetch, AJAX
console.log('Асинхронный код JS, Промисы/Promise, Fetch, AJAX');

// 1) Start Code
console.log(`____________________________________________________________________________________

`);

// * AJAX - Асинхронный JS и XML
// AJAX как аббревиатура расшифровывается как Асинхронный JS и XML
// На данный момент вся работа AJAX успешно выполняется на методе Fetch
console.log('AJAX - Асинхронный JS и XML');


// * Нужно запустить Live Server


// * 1) Fetch библиотека это замена XMLHttpRequest
// Fetch из под капота работает на Promise
console.log(`\n \n 1) Fetch библиотека это замена XMLHttpRequest`);

// Метод Fetch() получает как минимум один обязательный аргумент в виде строки URL запроса
const user = fetch('conspect_26.json');

// Получим Promise, то-есть ответ метода Fetch являвется Promise
console.log(user);

// * В браузере можем перейти во вкладку Network и увидеть наши документы.
// Если клинуть на conspect_26.json, то откроются данные:
//    Request URL - путь по которому мы обращаемся к файлу
//    Request Method - если никак не настраивать Fetch, то по умолчанию он отправляет GET запрос
//    Во вкладке Response мы увидим те данные, которые получили из передаваемого файла
//    Во вкладке Preview эти данные показаны в формате Json


// Попробуем вывести данные в консоль и обработать Promise через then()
user.then((response) => {
    // Получим объект, но не в том виде, в котором мы сможем с ним работать.
    console.log(response);
});

// * Преобразуем данные из объекта Response, нужно вернуть объект Response и использовать на нём метод Json и далее использовать цепочку then()
user
    .then(response => response.json())
    .then(data => {
        console.log(data);
    });




// * В переменную user после метода fetch() был занесён Promise, мы обрабатываем Promise и получаем объект Response, методом json мы раскрываем данные полученные от Response и в следующей цепочке then() мы уже получаем данные в удобоворимов виде




// * 2) Сокращённая запись метода Fetch и углубление
console.log(`\n \n 2) Сокращённая запись метода Fetch и углубление`);

// Извлекаем ресурс(файл) из сети и возвращаем Promise
fetch('conspect_26.json')
    // Преобразуем response/ответ Promise через метод json()
    .then(response => response.json())
    // Обрабатываем через then положительный ответ
    .then((data) => {
        // console.log(`2) Упрощённая запись метода Fetch`);
        console.log(data);
    })
    // Обрабатываем через catch отрицательный ответ
    .catch((error) => {
        console.log(error);
    });




// * 3) Что такое Status во вкладке Network?
// Когда мы делаем запрос на какой-то определённый URL, мы каждый раз будем получать какой-то Status, которых всего пять типов:
//  100-ые - информационные статусы, встречаются редко
//  200-ые - это счастье и успех =) Например 200 это успешное получение данных, а 201 это успешное сохрание данных
//  300-ые - статусы перенаправления. Например мы берём какие-то данные у сервера, принимаем их и допустим отрисовываем на странице, а потом делаем повторный запрос на тот же URL, сервер нам отвечает 304 статусом, который говорит, что данные не были изменены
//  400-ые - боль и страдание, но такая как 500-ые =) Например 404 означает not found, то-есть подобная точка на которую был запрос не найдена. Каждая 400-ая ошибка это ошибка клиентской части
//  500-ые - ошибки серверной части. Когда мы получаем 500-ые ошибки это означает, что мы отправили успешный запрос, но когда сервер получил запрос, он просто рухнул/сломался и что-то пошло не так. Когда получаем 500-ые ошибки, то самое время пойти к Back-end разработчику и узнать, что это было
console.log(`\n \n 3) Что такое Status во вкладке Network?`);




// * 4) https://jsonplaceholder.typicode.com/ - Попробуем получать данные с какого-нибудь тестового API
// https://jsonplaceholder.typicode.com/ - идеальный сервися для изучения запросов fetch()
// https://jsonplaceholder.typicode.com/posts/1
console.log(`\n \n 4) https://jsonplaceholder.typicode.com/ - Попробуем получать данные с какого-нибудь тестового API`);


// * Получим огромный массив с кучей данных
fetch('https://jsonplaceholder.typicode.com/posts')
    .then(response => response.json())
    .then((data) => {
        console.log(' \n \n 4-1) Получим огромный массив с кучей данных');
        console.log(data);
    })
    .catch((error) => {
        console.log(error);
    });


// * Получаем определённый элемент через его идентификатор, например /1
fetch('https://jsonplaceholder.typicode.com/posts/1')
    .then(response => response.json())
    .then((data) => {
        // Идеальная "точка" или момент then(), чтобы отрисовывать элементы на странице с информацией полученной от сервера
        console.log(' \n \n 4-2) Получаем определённый элемент через его идентификатор, например /1');
        console.log(data);
    })
    .catch((error) => {
        console.log(error);
    });


// * Настройка метода fetch - объект с настройками в виде аргумента
// * Метод GET служит для получения данных от сервера
// * Метод POST служит для отправки данных на сервер
// method - методы GET и POST
// body - тело запроса, тот объект, который мы будем отправлять. Бывает разных форматов и не всегда JSON
// headers - указываем какой будет Content-type. Бывают разных типов и зачастую зависят от Back-end части
fetch('https://jsonplaceholder.typicode.com/posts', {
    // Метод отправки, по умолчанию стоит GET
    method: 'POST',
    body: JSON.stringify({
        title: 'foo',
        body: 'bar',
        userId: 1,
    }),
    headers: {
        'Content-type': 'application/json; charset=UTF-8',
    },
})
    .then(response => response.json())
    .then((data) => {
        console.log(' \n \n 4-3) Настройка метода fetch - объект с настройками в виде аргумента');
        console.log(data);
    })
    .catch((error) => {
        console.log(error);
    });

